import express from 'express';
import cors from 'cors';
import path from 'path';
import fs from 'fs';
import {
	CanonicalPropertyProfile,
	ComparisonResult,
	ConsolidatedResponse,
	FieldMatchBreakdown,
	imagesSimilarityPercentByTitles,
	normalizeOtaA,
	normalizeOtaY,
	normalizeYanolja,
	setSimilarityPercent,
	stringSimilarityPercent,
	ImageItem,
} from '../../../packages/shared/dist';

const app = express();
app.use(cors());
app.use(express.json());

const DATA_ROOT = '../../data/Propery_Hub_JSON';

interface PropertyDatasetPaths {
	id: string;
	baseDir: string;
	yanolja?: string;
	otaA?: string;
	otaY?: string;
}

function listPropertyDatasets(): PropertyDatasetPaths[] {
	const result: PropertyDatasetPaths[] = [];
	const propertyDirs = fs
		.readdirSync(DATA_ROOT)
		.filter((name) => fs.statSync(path.join(DATA_ROOT, name)).isDirectory());
	for (const dir of propertyDirs) {
		const baseDir = path.join(DATA_ROOT, dir);
		const parts = dir.split('_');
		const probableId = parts[parts.length - 1];
		const p: PropertyDatasetPaths = { id: probableId, baseDir };
		const yanoljaDir = path.join(baseDir, 'Yanolja');
		const aDir = path.join(baseDir, 'A');
		const yDir = path.join(baseDir, 'Y');
		if (fs.existsSync(yanoljaDir)) {
			const files = fs.readdirSync(yanoljaDir).filter((f) => f.endsWith('.json'));
			if (files[0]) p.yanolja = path.join(yanoljaDir, files[0]);
		}
		if (fs.existsSync(aDir)) {
			const files = fs.readdirSync(aDir).filter((f) => f.endsWith('.json'));
			if (files[0]) p.otaA = path.join(aDir, files[0]);
		}
		if (fs.existsSync(yDir)) {
			const files = fs.readdirSync(yDir).filter((f) => f.endsWith('.json'));
			if (files[0]) p.otaY = path.join(yDir, files[0]);
		}
		result.push(p);
	}
	return result.sort((a, b) => a.id.localeCompare(b.id));
}

function readJson(filePath: string): any {
	const text = fs.readFileSync(filePath, 'utf-8');
	try {
		return JSON.parse(text);
	} catch (e) {
		// Some OTA files may contain trailing characters; try to sanitize
		throw new Error(`Failed to parse JSON: ${filePath}: ${(e as Error).message}`);
	}
}

function buildCanonical(
	paths: PropertyDatasetPaths
): { yanolja?: CanonicalPropertyProfile; a?: CanonicalPropertyProfile; y?: CanonicalPropertyProfile } {
	const yanoljaRaw = paths.yanolja ? readJson(paths.yanolja) : undefined;
	const yj = yanoljaRaw ? normalizeYanolja(yanoljaRaw) : undefined;
	const fallbackImages: ImageItem[] | undefined = yj?.images;
	const aRaw = paths.otaA ? readJson(paths.otaA) : undefined;
	const yRaw = paths.otaY ? readJson(paths.otaY) : undefined;
	const a = aRaw ? normalizeOtaA(aRaw, fallbackImages) : undefined;
	const y = yRaw ? normalizeOtaY(yRaw, fallbackImages) : undefined;
	return { yanolja: yj, a, y };
}

function computeScores(base: CanonicalPropertyProfile, other: CanonicalPropertyProfile): FieldMatchBreakdown {
	const name = stringSimilarityPercent(base.name ?? '', other.name ?? '');
	const address = stringSimilarityPercent(base.address ?? '', other.address ?? '');
	const images = imagesSimilarityPercentByTitles(
		(base.images || []).map((i: any) => i.title),
		(other.images || []).map((i: any) => i.title)
	);
	const facilities = setSimilarityPercent(base.facilities || [], other.facilities || []);
	const overall = Math.round((name * 0.35 + address * 0.35 + facilities * 0.2 + images * 0.1));
	return { name, address, images, facilities, overall };
}

app.get('/api/properties', (_req, res) => {
	const list = listPropertyDatasets().map((p) => ({ id: p.id }));
	res.json(list);
});

app.get('/api/properties/:id/raw', (req, res) => {
	const id = req.params.id;
	const set = listPropertyDatasets().find((p) => p.id === id);
	if (!set) return res.status(404).json({ error: 'Not found' });
	const yanolja = set.yanolja ? readJson(set.yanolja) : null;
	const a = set.otaA ? readJson(set.otaA) : null;
	const y = set.otaY ? readJson(set.otaY) : null;
	res.json({ yanolja, a, y });
});

app.get('/api/properties/:id', (req, res) => {
	const id = req.params.id;
	const set = listPropertyDatasets().find((p) => p.id === id);
	if (!set) return res.status(404).json({ error: 'Not found' });
	const { yanolja, a, y } = buildCanonical(set);
	if (!yanolja) return res.status(500).json({ error: 'Missing Yanolja base' });
	const canonical: CanonicalPropertyProfile = {
		...yanolja,
		id,
		primaryId: id,
		sourceIds: {
			Yanolja: yanolja.sourceIds.Yanolja,
			A: a?.sourceIds.A,
			Y: y?.sourceIds.Y,
		},
	};
	const comparisons: Partial<Record<'vsA' | 'vsY', ComparisonResult>> = {};
	if (a) comparisons.vsA = { base: 'Yanolja', target: 'A', scores: computeScores(yanolja, a) };
	if (y) comparisons.vsY = { base: 'Yanolja', target: 'Y', scores: computeScores(yanolja, y) };
	const response: ConsolidatedResponse = {
		id,
		canonical,
		comparisons,
		sourcesAvailability: { Yanolja: Boolean(yanolja), A: Boolean(a), Y: Boolean(y) },
	};
	res.json(response);
});

const port = process.env.PORT ? Number(process.env.PORT) : 3001;
app.listen(port, () => {
	console.log(`API listening on http://localhost:${port}`);
});